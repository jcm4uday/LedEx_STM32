/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// #include "stm32f4xx.h" // Include the appropriate header file for your STM32 family

#include <stdint.h> // Include standard integer types

#define LED_PIN_12 12 // LED 4
#define LED_PIN_13 13 // LED 3
#define LED_PIN_14 14 // LED 5
#define LED_PIN_15 15 // LED 6
#define LED_PORT GPIO_D // Assuming GPIO_D is defined for the LED port

#define RCC_BASE_ADDRESS 0x40023800 // Base address for RCC
#define GPIO_D_BASE_ADDRESS 0x40020C00 // Base address for GPIO D
#define GPIO_DENR_OFFSET 0x30 // Offset for GPIO D clock enable register

// Define the GPIO D clock enable register address
#define GPIO_D_CLOCK_ENABLE (RCC_BASE_ADDRESS + GPIO_DENR_OFFSET)

// Define the LED port base address
#define GPIO_D ((volatile uint32_t *)GPIO_D_BASE_ADDRESS)

// Define the LED pin states
#define LED_ON 1
#define LED_OFF 0

// Function prototypes
void GPIO_Init(void);
void delay(uint32_t ms);
void Toggle_LED(void);

// Function definitions

void GPIO_Init(void)
{
    // Enable clock for GPIO D
    volatile uint32_t * RCC_AHB1ENR = (volatile uint32_t *)GPIO_D_CLOCK_ENABLE; // RCC AHB1ENR address

    *RCC_AHB1ENR |= (1 << 3); // Set bit 3 to enable clock for GPIO D (assuming GPIO D is the 4th GPIO port)

    // Wait for the clock to stabilize (optional, depending on the microcontroller)
    // This is usually not necessary for most STM32 devices, but can be included for safety

    // Configure GPIO D pins 12-15 as output
    // Assuming GPIO D is used for LEDs connected to pins 12-15
    // Set MODER register for GPIO D to configure pins 12-15 as output
    // Each pin takes 2 bits in the MODER register, so we set bits accordingly

    // Configure LED pin as output
    volatile uint32_t * GPIO_D_MODER = GPIO_D; // Base address for GPIO D MODER
    *GPIO_D_MODER |= (1 << (LED_PIN_12 * 2)); // Set pin 12 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_13 * 2)); // Set pin 13 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_14 * 2)); // Set pin 14 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_15 * 2)); // Set pin 15 as output

    // // Optionally, configure the output type, speed, and pull-up/pull-down resistors if needed
    // // For example, set the output type to push-pull and speed to high
    // uint32_t * GPIO_D_OTYPER = (uint32_t *)0x40020C04; // Base address for GPIO D OTYPER
    // *GPIO_D_OTYPER &= ~(0xF << LED_PIN_12); // Set pins 12-15 to push-pull

    // uint32_t * GPIO_D_OSPEEDR = (uint32_t *)0x40020C08; // Base address for GPIO D OSPEEDR
    // *GPIO_D_OSPEEDR |= (0xF << (LED_PIN_12 * 2)); // Set pins 12-15 to high speed

    // uint32_t * GPIO_D_PUPDR = (uint32_t *)0x40020C0C; // Base address for GPIO D PUPDR
    // *GPIO_D_PUPDR &= ~(0xF << (LED_PIN_12 * 2)); // No pull-up, no pull-down for pins 12-15
    // This is a basic configuration; additional settings may be required based on the specific hardware
    // and the STM32 family being used.
    // Ensure to include necessary headers and definitions for the specific STM32 family.
    // For example, you might need to include stm32f4xx.h or similar header files.
    // Also, ensure that the clock for GPIO D is enabled in the RCC (Reset and Clock Control) registers.
    // This is typically done in the system initialization code or before using the GPIO.
    // Example: RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // Enable clock for GPIO D

}

void delay(uint32_t ms)
{
    // Implement a delay function that waits for the specified milliseconds
    // This could be done using a simple loop or a timer
    volatile uint32_t count;
    for (count = 0; count < ms * 1000; count++)
    {
        // A simple busy-wait loop
        // This is not the most efficient way to implement a delay, but it is simple
        // In a real application, you might want to use a hardware timer or a more accurate delay function
    }
    // This delay function is a simple busy-wait loop that may not be accurate
    // For more precise timing, consider using a hardware timer or an RTOS delay function
}

void Toggle_LED(void)
{
    // Toggle the state of the LED pin
    // This could be done by reading the current state and writing the opposite state
    volatile uint32_t * GPIO_D_ODR = (volatile uint32_t *)(GPIO_D_BASE_ADDRESS + 0x14); // Output Data Register address
    *GPIO_D_ODR ^= (1 << LED_PIN_12); // Toggle pin 12
    *GPIO_D_ODR ^= (1 << LED_PIN_13); // Toggle pin 13
    *GPIO_D_ODR ^= (1 << LED_PIN_14); // Toggle pin 14
    *GPIO_D_ODR ^= (1 << LED_PIN_15); // Toggle pin 15
    
    // This function toggles the state of the LEDs connected to pins 12-15
    // It uses the Output Data Register (ODR) to read and write the pin states
    // Ensure that the GPIO D is properly initialized before calling this function
}



int main(void)
{
    // Initialize the GPIO for the LED
    GPIO_Init();

    // Main loop
    while (1)
    {
        // Toggle the LED
        Toggle_LED();

        // Delay for 500 milliseconds
        delay(500);
    }

    // Should never reach here
    // This is just to satisfy the compiler, as the main function should never exit
    // In a real embedded application, the program would run indefinitely
    return 0;
}
