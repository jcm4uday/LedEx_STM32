/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

// #include "stm32f4xx.h" // Include the appropriate header file for your STM32 family

#include <stdint.h> // Include standard integer types

#include "portConfig.h" // Include the port configuration header
#include "toggleLed.h" // Include the toggle LED header
#include "hwTimer.h" // Include the hardware timer header

// Function prototypes
void GPIO_Init(void);
void delay(uint32_t ms);

// Function definitions

void GPIO_Init(void)
{
    // Enable clock for GPIO D
    volatile uint32_t * RCC_AHB1ENR = (volatile uint32_t *)GPIO_D_CLOCK_ENABLE; // RCC AHB1ENR address

    *RCC_AHB1ENR |= (1 << 3); // Set bit 3 to enable clock for GPIO D (assuming GPIO D is the 4th GPIO port)

    // Enable clock for TIM2
    volatile uint32_t * RCC_APB1ENR = (volatile uint32_t *)TIM2_CLOCK_ENABLE; // RCC APB1ENR address
    *RCC_APB1ENR |= (1 << 0); // Set bit 0 to enable clock for TIM2 

    // Wait for the clock to stabilize (optional, depending on the microcontroller)
    // This is usually not necessary for most STM32 devices, but can be included for safety

    // Configure GPIO D pins 12-15 as output
    // Assuming GPIO D is used for LEDs connected to pins 12-15
    // Set MODER register for GPIO D to configure pins 12-15 as output
    // Each pin takes 2 bits in the MODER register, so we set bits accordingly

    // Configure LED pin as output
    volatile uint32_t * GPIO_D_MODER = GPIO_D; // Base address for GPIO D MODER
    *GPIO_D_MODER |= (1 << (LED_PIN_12 * 2)); // Set pin 12 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_13 * 2)); // Set pin 13 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_14 * 2)); // Set pin 14 as output
    *GPIO_D_MODER |= (1 << (LED_PIN_15 * 2)); // Set pin 15 as output

    // // Optionally, configure the output type, speed, and pull-up/pull-down resistors if needed
    // // For example, set the output type to push-pull and speed to high
    // uint32_t * GPIO_D_OTYPER = (uint32_t *)0x40020C04; // Base address for GPIO D OTYPER
    // *GPIO_D_OTYPER &= ~(0xF << LED_PIN_12); // Set pins 12-15 to push-pull

    // uint32_t * GPIO_D_OSPEEDR = (uint32_t *)0x40020C08; // Base address for GPIO D OSPEEDR
    // *GPIO_D_OSPEEDR |= (0xF << (LED_PIN_12 * 2)); // Set pins 12-15 to high speed

    // uint32_t * GPIO_D_PUPDR = (uint32_t *)0x40020C0C; // Base address for GPIO D PUPDR
    // *GPIO_D_PUPDR &= ~(0xF << (LED_PIN_12 * 2)); // No pull-up, no pull-down for pins 12-15
    // This is a basic configuration; additional settings may be required based on the specific hardware
    // and the STM32 family being used.
    // Ensure to include necessary headers and definitions for the specific STM32 family.
    // For example, you might need to include stm32f4xx.h or similar header files.
    // Also, ensure that the clock for GPIO D is enabled in the RCC (Reset and Clock Control) registers.
    // This is typically done in the system initialization code or before using the GPIO.
    // Example: RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; // Enable clock for GPIO D

}

void delay(uint32_t ms)
{
    // Implement a delay function that waits for the specified milliseconds
    // This could be done using a simple loop or a timer
    volatile uint32_t count;
    for (count = 0; count < ms * 1000; count++)
    {
        // A simple busy-wait loop
        // This is not the most efficient way to implement a delay, but it is simple
        // In a real application, you might want to use a hardware timer or a more accurate delay function
    }
    // This delay function is a simple busy-wait loop that may not be accurate
    // For more precise timing, consider using a hardware timer or an RTOS delay function
}



int main(void)
{
    // Initialize the GPIO for the LED
    GPIO_Init();
    hwTimer_Init((uint32_t *)TIM2_BASE_ADDRESS); // Initialize the hardware timer with TIM2 base address
       

    // Main loop
    while (1)
    {
        hwTimer_Start((uint32_t *)TIM2_BASE_ADDRESS); // Start the hardware timer
        // Toggle the LED
        Toggle_LED();

        // Delay for 500 milliseconds
        // delay(500);
        hwTimer_Stop((uint32_t *)TIM2_BASE_ADDRESS); // Stop the hardware timer
    }

    // Should never reach here
    // This is just to satisfy the compiler, as the main function should never exit
    // In a real embedded application, the program would run indefinitely
    return 0;
}
